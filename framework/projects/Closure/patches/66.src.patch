--- src/com/google/javascript/jscomp/TypeCheck.java	2025-05-20 23:09:37
+++ ./src/com/google/javascript/jscomp/TypeCheck.java	2025-05-20 23:09:37
@@ -458,360 +458,34 @@
    * @param n The node being visited.
    * @param parent The parent of the node n.
    */
-  public void visit(NodeTraversal t, Node n, Node parent) {
-    JSType childType;
-    JSType leftType, rightType;
-    Node left, right;
+  public void visit(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarCurrentParent) {
+    if (!(!(false))) {
+        System.out.println("log");
+    }
+    JSType TransVarChild;
+    JSType TransVarType, TransVarRightTypeValue;
+    Node TransVarLeftNode, TransVarRightNode;
     // To be explicitly set to false if the node is not typeable.
-    boolean typeable = true;
+    boolean TransVarTypeValue = true;
 
-    switch (n.getType()) {
-      case Token.NAME:
-        typeable = visitName(t, n, parent);
-        break;
-
-      case Token.LP:
-        // If this is under a FUNCTION node, it is a parameter list and can be
-        // ignored here.
-        if (parent.getType() != Token.FUNCTION) {
-          ensureTyped(t, n, getJSType(n.getFirstChild()));
-        } else {
-          typeable = false;
+    boolean TransFallThroughFlag0 = false;
+    boolean TransBreakFlag0 = true;
+    {if (!(!(false))) {
+            System.out.println("log");
         }
-        break;
-
-      case Token.COMMA:
-        ensureTyped(t, n, getJSType(n.getLastChild()));
-        break;
-
-      case Token.TRUE:
-      case Token.FALSE:
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.THIS:
-        ensureTyped(t, n, t.getScope().getTypeOfThis());
-        break;
-
-      case Token.REF_SPECIAL:
-        ensureTyped(t, n);
-        break;
-
-      case Token.GET_REF:
-        ensureTyped(t, n, getJSType(n.getFirstChild()));
-        break;
-
-      case Token.NULL:
-        ensureTyped(t, n, NULL_TYPE);
-        break;
-
-      case Token.NUMBER:
-        ensureTyped(t, n, NUMBER_TYPE);
-        break;
-
-      case Token.STRING:
-        // Object literal keys are handled with OBJECTLIT
-        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
-          ensureTyped(t, n, STRING_TYPE);
-        } else {
-          // Object literal keys are not typeable
-          typeable = false;
+    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))){if (!(!(false))) {
+            System.out.println("log");
         }
-        break;
+    TransBreakFlag0=false;TransVarTypeValue=visitName(TransVarTraversal,TransVarNode,TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LP))))){TransBreakFlag0=false;if (!(!(TransVarCurrentParent.getType() != Token.FUNCTION))){ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));} else {TransVarTypeValue=false;}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.COMMA))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getLastChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FALSE))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THIS))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,TransVarTraversal.getScope().getTypeOfThis());}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REF_SPECIAL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET_REF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NULL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NULL_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NUMBER))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.STRING))))){TransBreakFlag0=false;if (!(!(!NodeUtil.isObjectLitKey(TransVarNode, TransVarNode.getParent())))){ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SET))))){TransBreakFlag0=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ARRAYLIT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,ARRAY_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REGEXP))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,REGEXP_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))){TransBreakFlag0=false;visitGetProp(TransVarTraversal,TransVarNode,TransVarCurrentParent);TransVarTypeValue=!(TransVarCurrentParent.getType() == Token.ASSIGN && TransVarCurrentParent.getFirstChild() == TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETELEM))))){TransBreakFlag0=false;visitGetElem(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))){TransBreakFlag0=false;visitVar(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEW))))){TransBreakFlag0=false;visitNew(TransVarTraversal,TransVarNode);TransVarTypeValue=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CALL))))){TransBreakFlag0=false;visitCall(TransVarTraversal,TransVarNode);TransVarTypeValue=!NodeUtil.isExpressionNode(TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RETURN))))){TransBreakFlag0=false;visitReturn(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEC))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INC))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),"increment/decrement");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NOT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VOID))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,VOID_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TYPEOF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITNOT))))){TransBreakFlag0=false;TransVarChild=getJSType(TransVarNode.getFirstChild());if (!(!(!TransVarChild.matchesInt32Context()))){report(TransVarTraversal,TransVarNode,BIT_OPERATION,NodeUtil.opToStr(TransVarNode.getType()),TransVarChild.toString());}ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.POS))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEG))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),"sign operator");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeValue=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightTypeNotNullOrUndefined=TransVarRightTypeValue.restrictByNotNullOrUndefined();TernaryValue TransVarTernaryValue=TransVarLeftTypeValue.testForEquality(TransVarRightTypeNotNullOrUndefined);if (!(!(TransVarTernaryValue != TernaryValue.UNKNOWN))){if (!(!(TransVarNode.getType() == Token.NE))){TransVarTernaryValue=TransVarTernaryValue.not();}report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST,TransVarType.toString(),TransVarRightTypeValue.toString(),TransVarTernaryValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHEQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHNE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeRestrictedNotNullOrUndefined=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightType=TransVarRightTypeValue.restrictByNotNullOrUndefined();if (!(!(!TransVarLeftTypeRestrictedNotNullOrUndefined.canTestForShallowEqualityWith(TransVarRightType)))){report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST_NO_RESULT,TransVarType.toString(),TransVarRightTypeValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());if (!(!(TransVarRightTypeValue.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarType,"left side of numeric comparison");} else if (!(!(TransVarType.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarRightTypeValue,"right side of numeric comparison");} else if (!(!(TransVarType.matchesNumberContext() && TransVarRightTypeValue.matchesNumberContext()))){} else {String TransVarMessage2="left side of comparison";validator.expectString(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2,getNativeType(STRING_TYPE));TransVarMessage2="right side of comparison";validator.expectString(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2,getNativeType(STRING_TYPE));}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IN))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode);validator.expectObject(TransVarTraversal,TransVarNode,TransVarRightTypeValue,"'in' requires an object");validator.expectString(TransVarTraversal,TransVarLeftNode,TransVarType,"left side of 'in'");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INSTANCEOF))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode).restrictByNotNullOrUndefined();validator.expectAnyObject(TransVarTraversal,TransVarLeftNode,TransVarType,"deterministic instanceof yields false");validator.expectActualObject(TransVarTraversal,TransVarRightNode,TransVarRightTypeValue,"instanceof requires an object");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN))))){TransBreakFlag0=false;visitAssign(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MUL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MUL))))){TransBreakFlag0=false;visitBinaryOperator(TransVarNode.getType(),TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DELPROP))))){TransBreakFlag0=false;if (!(!(!isReference(TransVarNode.getFirstChild())))){report(TransVarTraversal,TransVarNode,BAD_DELETE);}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CASE))))){TransBreakFlag0=false;JSType TransVarSwitchType2=getJSType(TransVarCurrentParent.getFirstChild());JSType TransVarCaseType2=getJSType(TransVarNode.getFirstChild());validator.expectSwitchMatchesCase(TransVarTraversal,TransVarNode,TransVarSwitchType2,TransVarCaseType2);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WITH))))){TransBreakFlag0=false;Node TransVarChildNode=TransVarNode.getFirstChild();TransVarChild=getJSType(TransVarChildNode);validator.expectObject(TransVarTraversal,TransVarChildNode,TransVarChild,"with requires an object");TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))){TransBreakFlag0=false;visitFunction(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL_NAME))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SWITCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BREAK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CATCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EXPR_RESULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EMPTY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEFAULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CONTINUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEBUGGER))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THROW))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OBJECTLIT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))){TransBreakFlag0=false;if (!(!(TransVarNode.getJSType() != null))){ensureTyped(TransVarTraversal,TransVarNode);} else {if (!(!((TransVarNode.getType() == Token.OBJECTLIT) && (TransVarCurrentParent.getJSType() instanceof EnumType)))){ensureTyped(TransVarTraversal,TransVarNode,TransVarCurrentParent.getJSType());} else {ensureTyped(TransVarTraversal,TransVarNode);}}if (!(!(TransVarNode.getType() == Token.OBJECTLIT))){for (Node TransVarChildKey:TransVarNode.children()){visitObjLitKey(TransVarTraversal,TransVarChildKey,TransVarNode);}}}if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))){report(TransVarTraversal,TransVarNode,UNEXPECTED_TOKEN,Token.name(TransVarNode.getType()));ensureTyped(TransVarTraversal,TransVarNode);}}
 
-      case Token.GET:
-      case Token.SET:
-        // Object literal keys are handled with OBJECTLIT
-        break;
-
-      case Token.ARRAYLIT:
-        ensureTyped(t, n, ARRAY_TYPE);
-        break;
-
-      case Token.REGEXP:
-        ensureTyped(t, n, REGEXP_TYPE);
-        break;
-
-      case Token.GETPROP:
-        visitGetProp(t, n, parent);
-        typeable = !(parent.getType() == Token.ASSIGN &&
-                     parent.getFirstChild() == n);
-        break;
-
-      case Token.GETELEM:
-        visitGetElem(t, n);
-        // The type of GETELEM is always unknown, so no point counting that.
-        // If that unknown leaks elsewhere (say by an assignment to another
-        // variable), then it will be counted.
-        typeable = false;
-        break;
-
-      case Token.VAR:
-        visitVar(t, n);
-        typeable = false;
-        break;
-
-      case Token.NEW:
-        visitNew(t, n);
-        typeable = true;
-        break;
-
-      case Token.CALL:
-        visitCall(t, n);
-        typeable = !NodeUtil.isExpressionNode(parent);
-        break;
-
-      case Token.RETURN:
-        visitReturn(t, n);
-        typeable = false;
-        break;
-
-      case Token.DEC:
-      case Token.INC:
-        left = n.getFirstChild();
-        validator.expectNumber(
-            t, left, getJSType(left), "increment/decrement");
-        ensureTyped(t, n, NUMBER_TYPE);
-        break;
-
-      case Token.NOT:
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.VOID:
-        ensureTyped(t, n, VOID_TYPE);
-        break;
-
-      case Token.TYPEOF:
-        ensureTyped(t, n, STRING_TYPE);
-        break;
-
-      case Token.BITNOT:
-        childType = getJSType(n.getFirstChild());
-        if (!childType.matchesInt32Context()) {
-          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
-              childType.toString());
-        }
-        ensureTyped(t, n, NUMBER_TYPE);
-        break;
-
-      case Token.POS:
-      case Token.NEG:
-        left = n.getFirstChild();
-        validator.expectNumber(t, left, getJSType(left), "sign operator");
-        ensureTyped(t, n, NUMBER_TYPE);
-        break;
-
-      case Token.EQ:
-      case Token.NE: {
-        leftType = getJSType(n.getFirstChild());
-        rightType = getJSType(n.getLastChild());
-
-        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
-        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
-        TernaryValue result =
-            leftTypeRestricted.testForEquality(rightTypeRestricted);
-        if (result != TernaryValue.UNKNOWN) {
-          if (n.getType() == Token.NE) {
-            result = result.not();
-          }
-          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
-              rightType.toString(), result.toString());
-        }
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-      }
-
-      case Token.SHEQ:
-      case Token.SHNE: {
-        leftType = getJSType(n.getFirstChild());
-        rightType = getJSType(n.getLastChild());
-
-        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
-        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
-        if (!leftTypeRestricted.canTestForShallowEqualityWith(
-                rightTypeRestricted)) {
-          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
-              rightType.toString());
-        }
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-      }
-
-      case Token.LT:
-      case Token.LE:
-      case Token.GT:
-      case Token.GE:
-        leftType = getJSType(n.getFirstChild());
-        rightType = getJSType(n.getLastChild());
-        if (rightType.isNumber()) {
-          validator.expectNumber(
-              t, n, leftType, "left side of numeric comparison");
-        } else if (leftType.isNumber()) {
-          validator.expectNumber(
-              t, n, rightType, "right side of numeric comparison");
-        } else if (leftType.matchesNumberContext() &&
-                   rightType.matchesNumberContext()) {
-          // OK.
-        } else {
-          // Whether the comparison is numeric will be determined at runtime
-          // each time the expression is evaluated. Regardless, both operands
-          // should match a string context.
-          String message = "left side of comparison";
-          validator.expectString(t, n, leftType, message);
-          validator.expectNotNullOrUndefined(
-              t, n, leftType, message, getNativeType(STRING_TYPE));
-          message = "right side of comparison";
-          validator.expectString(t, n, rightType, message);
-          validator.expectNotNullOrUndefined(
-              t, n, rightType, message, getNativeType(STRING_TYPE));
-        }
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.IN:
-        left = n.getFirstChild();
-        right = n.getLastChild();
-        leftType = getJSType(left);
-        rightType = getJSType(right);
-        validator.expectObject(t, n, rightType, "'in' requires an object");
-        validator.expectString(t, left, leftType, "left side of 'in'");
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.INSTANCEOF:
-        left = n.getFirstChild();
-        right = n.getLastChild();
-        leftType = getJSType(left);
-        rightType = getJSType(right).restrictByNotNullOrUndefined();
-
-        validator.expectAnyObject(
-            t, left, leftType, "deterministic instanceof yields false");
-        validator.expectActualObject(
-            t, right, rightType, "instanceof requires an object");
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.ASSIGN:
-        visitAssign(t, n);
-        typeable = false;
-        break;
-
-      case Token.ASSIGN_LSH:
-      case Token.ASSIGN_RSH:
-      case Token.ASSIGN_URSH:
-      case Token.ASSIGN_DIV:
-      case Token.ASSIGN_MOD:
-      case Token.ASSIGN_BITOR:
-      case Token.ASSIGN_BITXOR:
-      case Token.ASSIGN_BITAND:
-      case Token.ASSIGN_SUB:
-      case Token.ASSIGN_ADD:
-      case Token.ASSIGN_MUL:
-      case Token.LSH:
-      case Token.RSH:
-      case Token.URSH:
-      case Token.DIV:
-      case Token.MOD:
-      case Token.BITOR:
-      case Token.BITXOR:
-      case Token.BITAND:
-      case Token.SUB:
-      case Token.ADD:
-      case Token.MUL:
-        visitBinaryOperator(n.getType(), t, n);
-        break;
-
-      case Token.DELPROP:
-        if (!isReference(n.getFirstChild())) {
-          report(t, n, BAD_DELETE);
-        }
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-
-      case Token.CASE:
-        JSType switchType = getJSType(parent.getFirstChild());
-        JSType caseType = getJSType(n.getFirstChild());
-        validator.expectSwitchMatchesCase(t, n, switchType, caseType);
-        typeable = false;
-        break;
-
-      case Token.WITH: {
-        Node child = n.getFirstChild();
-        childType = getJSType(child);
-        validator.expectObject(
-            t, child, childType, "with requires an object");
-        typeable = false;
-        break;
-      }
-
-      case Token.FUNCTION:
-        visitFunction(t, n);
-        break;
-
-      // These nodes have no interesting type behavior.
-      case Token.LABEL:
-      case Token.LABEL_NAME:
-      case Token.SWITCH:
-      case Token.BREAK:
-      case Token.CATCH:
-      case Token.TRY:
-      case Token.SCRIPT:
-      case Token.EXPR_RESULT:
-      case Token.BLOCK:
-      case Token.EMPTY:
-      case Token.DEFAULT:
-      case Token.CONTINUE:
-      case Token.DEBUGGER:
-      case Token.THROW:
-        typeable = false;
-        break;
-
-      // These nodes require data flow analysis.
-      case Token.DO:
-      case Token.FOR:
-      case Token.IF:
-      case Token.WHILE:
-        typeable = false;
-        break;
-
-      // These nodes are typed during the type inference.
-      case Token.AND:
-      case Token.HOOK:
-      case Token.OBJECTLIT:
-      case Token.OR:
-        if (n.getJSType() != null) { // If we didn't run type inference.
-          ensureTyped(t, n);
-        } else {
-          // If this is an enum, then give that type to the objectlit as well.
-          if ((n.getType() == Token.OBJECTLIT)
-              && (parent.getJSType() instanceof EnumType)) {
-            ensureTyped(t, n, parent.getJSType());
-          } else {
-            ensureTyped(t, n);
-          }
-        }
-        if (n.getType() == Token.OBJECTLIT) {
-          for (Node key : n.children()) {
-            visitObjLitKey(t, key, n);
-          }
-        }
-        break;
-
-      default:
-        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
-        ensureTyped(t, n);
-        break;
-    }
-
     // Don't count externs since the user's code may not even use that part.
-    typeable = typeable && !inExterns;
+    TransVarTypeValue = TransVarTypeValue && !inExterns;
 
-    if (typeable) {
-      doPercentTypedAccounting(t, n);
+    if (!(!(TransVarTypeValue))) {
+      doPercentTypedAccounting(TransVarTraversal, TransVarNode);
     }
 
-    checkNoTypeCheckSection(n, false);
+    checkNoTypeCheckSection(TransVarNode, false);
   }
 
   /**
