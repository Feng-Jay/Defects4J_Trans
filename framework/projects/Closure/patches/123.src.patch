--- src/com/google/javascript/jscomp/CodeGenerator.java	2025-05-20 23:06:18
+++ ./src/com/google/javascript/jscomp/CodeGenerator.java	2025-05-20 23:06:18
@@ -104,670 +104,599 @@
     add(n, Context.OTHER);
   }
 
-  void add(Node n, Context context) {
-    if (!cc.continueProcessing()) {
+  void add(Node TransVarNode, Context TransVarCtx) {
+    if (!(!(false))) {
+        System.out.println("log");
+    }
+    if (!(!(!cc.continueProcessing()))) {
+      if (!(!(false))) {
+            System.out.println("log");
+        }
       return;
     }
 
-    int type = n.getType();
-    String opstr = NodeUtil.opToStr(type);
-    int childCount = n.getChildCount();
-    Node first = n.getFirstChild();
-    Node last = n.getLastChild();
+    int TransVarNodeType = TransVarNode.getType();
+    String TransVarOp = NodeUtil.opToStr(TransVarNodeType);
+    int TransVarChildCount2 = TransVarNode.getChildCount();
+    Node TransVarNode1 = TransVarNode.getFirstChild();
+    Node TransVarLastNode = TransVarNode.getLastChild();
 
     // Handle all binary operators
-    if (opstr != null && first != last) {
+    if (!(!(TransVarOp != null && TransVarNode1 != TransVarLastNode))) {
+      if (!(!(false))) {
+            System.out.println("log");
+        }
       Preconditions.checkState(
-          childCount == 2,
+          TransVarChildCount2 == 2,
           "Bad binary operator \"%s\": expected 2 arguments but got %s",
-          opstr, childCount);
-      int p = NodeUtil.precedence(type);
+          TransVarOp, TransVarChildCount2);
+      int TransVarPrecedence = NodeUtil.precedence(TransVarNodeType);
 
       // For right-hand-side of operations, only pass context if it's
       // the IN_FOR_INIT_CLAUSE one.
-      Context rhsContext = getContextForNoInOperator(context);
+      Context TransVarRhsCtx = getContextForNoInOperator(TransVarCtx);
 
       // Handle associativity.
       // e.g. if the parse tree is a * (b * c),
       // we can simply generate a * b * c.
-      if (last.getType() == type &&
-          NodeUtil.isAssociative(type)) {
-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
-        addExpr(last, p, rhsContext);
-      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
+      if (!(!(TransVarLastNode.getType() == TransVarNodeType && NodeUtil.isAssociative(TransVarNodeType)))) {
+        addExpr(TransVarNode1, TransVarPrecedence, TransVarCtx);
+        cc.addOp(TransVarOp, true);
+        addExpr(TransVarLastNode, TransVarPrecedence, TransVarRhsCtx);
+      } else if (!(!(NodeUtil.isAssignmentOp(TransVarNode) && NodeUtil.isAssignmentOp(TransVarLastNode)))) {
         // Assignments are the only right-associative binary operators
-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
-        addExpr(last, p, rhsContext);
+        addExpr(TransVarNode1, TransVarPrecedence, TransVarCtx);
+        cc.addOp(TransVarOp, true);
+        addExpr(TransVarLastNode, TransVarPrecedence, TransVarRhsCtx);
       } else {
-        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
+        unrollBinaryOperator(TransVarNode, TransVarNodeType, TransVarOp, TransVarCtx, TransVarRhsCtx, TransVarPrecedence, TransVarPrecedence + 1);
       }
       return;
     }
 
-    cc.startSourceMapping(n);
+    cc.startSourceMapping(TransVarNode);
 
-    switch (type) {
-      case Token.TRY: {
-        Preconditions.checkState(first.getNext().isBlock() &&
-                !first.getNext().hasMoreThanOneChild());
-        Preconditions.checkState(childCount >= 2 && childCount <= 3);
-
+    boolean TransFallThroughFlag0 = false;
+    boolean TransBreakFlag0 = true;
+    {
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TRY))))) {
+            TransBreakFlag0 = false;
+            Preconditions
+                    .checkState(TransVarNode1.getNext().isBlock() && !TransVarNode1.getNext().hasMoreThanOneChild());
+            Preconditions.checkState(TransVarChildCount2 >= 2 && TransVarChildCount2 <= 3);
         add("try");
-        add(first, Context.PRESERVE_BLOCK);
-
-        // second child contains the catch block, or nothing if there
-        // isn't a catch block
-        Node catchblock = first.getNext().getFirstChild();
-        if (catchblock != null) {
-          add(catchblock);
+            add(TransVarNode1, Context.PRESERVE_BLOCK);
+            Node TransVarCatchBlock = TransVarNode1.getNext().getFirstChild();
+            if (!(!(TransVarCatchBlock != null))) {
+                add(TransVarCatchBlock);
         }
-
-        if (childCount == 3) {
+            if (!(!(TransVarChildCount2 == 3))) {
           add("finally");
-          add(last, Context.PRESERVE_BLOCK);
+                add(TransVarLastNode, Context.PRESERVE_BLOCK);
         }
-        break;
       }
-
-      case Token.CATCH:
-        Preconditions.checkState(childCount == 2);
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CATCH))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
         add("catch(");
-        add(first);
+            add(TransVarNode1);
         add(")");
-        add(last, Context.PRESERVE_BLOCK);
-        break;
-
-      case Token.THROW:
-        Preconditions.checkState(childCount == 1);
+            add(TransVarLastNode, Context.PRESERVE_BLOCK);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.THROW))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
         add("throw");
-        add(first);
-
-        // Must have a ';' after a throw statement, otherwise safari can't
-        // parse this.
+            add(TransVarNode1);
         cc.endStatement(true);
-        break;
-
-      case Token.RETURN:
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.RETURN))))) {
+            TransBreakFlag0 = false;
         add("return");
-        if (childCount == 1) {
-          add(first);
+            if (!(!(TransVarChildCount2 == 1))) {
+                add(TransVarNode1);
         } else {
-          Preconditions.checkState(childCount == 0);
+                Preconditions.checkState(TransVarChildCount2 == 0);
         }
         cc.endStatement();
-        break;
-
-      case Token.VAR:
-        if (first != null) {
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.VAR))))) {
+            TransBreakFlag0 = false;
+            if (!(!(TransVarNode1 != null))) {
           add("var ");
-          addList(first, false, getContextForNoInOperator(context));
+                addList(TransVarNode1, false, getContextForNoInOperator(TransVarCtx));
         }
-        break;
-
-      case Token.LABEL_NAME:
-        Preconditions.checkState(!n.getString().isEmpty());
-        addIdentifier(n.getString());
-        break;
-
-      case Token.NAME:
-        if (first == null || first.isEmpty()) {
-          addIdentifier(n.getString());
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.LABEL_NAME))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(!TransVarNode.getString().isEmpty());
+            addIdentifier(TransVarNode.getString());
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NAME))))) {
+            TransBreakFlag0 = false;
+            if (!(!(TransVarNode1 == null || TransVarNode1.isEmpty()))) {
+                addIdentifier(TransVarNode.getString());
         } else {
-          Preconditions.checkState(childCount == 1);
-          addIdentifier(n.getString());
+                Preconditions.checkState(TransVarChildCount2 == 1);
+                addIdentifier(TransVarNode.getString());
           cc.addOp("=", true);
-          if (first.isComma()) {
-            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
+                if (!(!(TransVarNode1.isComma()))) {
+                    addExpr(TransVarNode1, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
           } else {
-            // Add expression, consider nearby code at lowest level of
-            // precedence.
-            addExpr(first, 0, getContextForNoInOperator(context));
+                    addExpr(TransVarNode1, 0, getContextForNoInOperator(TransVarCtx));
           }
         }
-        break;
-
-      case Token.ARRAYLIT:
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.ARRAYLIT))))) {
+            TransBreakFlag0 = false;
         add("[");
-        addArrayList(first);
+            addArrayList(TransVarNode1);
         add("]");
-        break;
-
-      case Token.PARAM_LIST:
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.PARAM_LIST))))) {
+            TransBreakFlag0 = false;
         add("(");
-        addList(first);
+            addList(TransVarNode1);
         add(")");
-        break;
-
-      case Token.COMMA:
-        Preconditions.checkState(childCount == 2);
-        unrollBinaryOperator(n, Token.COMMA, ",", context,
-            getContextForNoInOperator(context), 0, 0);
-        break;
-
-      case Token.NUMBER:
-        Preconditions.checkState(childCount == 0);
-        cc.addNumber(n.getDouble());
-        break;
-
-      case Token.TYPEOF:
-      case Token.VOID:
-      case Token.NOT:
-      case Token.BITNOT:
-      case Token.POS: {
-        // All of these unary operators are right-associative
-        Preconditions.checkState(childCount == 1);
-        cc.addOp(NodeUtil.opToStrNoFail(type), false);
-        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
-        break;
       }
-
-      case Token.NEG: {
-        Preconditions.checkState(childCount == 1);
-
-        // It's important to our sanity checker that the code
-        // we print produces the same AST as the code we parse back.
-        // NEG is a weird case because Rhino parses "- -2" as "2".
-        if (n.getFirstChild().isNumber()) {
-          cc.addNumber(-n.getFirstChild().getDouble());
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.COMMA))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
+            unrollBinaryOperator(TransVarNode, Token.COMMA, ",", TransVarCtx, getContextForNoInOperator(TransVarCtx), 0,
+                    0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NUMBER))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
+            cc.addNumber(TransVarNode.getDouble());
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TYPEOF))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.VOID))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NOT))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BITNOT))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.POS))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
+            cc.addOp(NodeUtil.opToStrNoFail(TransVarNodeType), false);
+            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), Context.OTHER);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NEG))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
+            if (!(!(TransVarNode.getFirstChild().isNumber()))) {
+                cc.addNumber(-TransVarNode.getFirstChild().getDouble());
         } else {
-          cc.addOp(NodeUtil.opToStrNoFail(type), false);
-          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
+                cc.addOp(NodeUtil.opToStrNoFail(TransVarNodeType), false);
+                addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), Context.OTHER);
         }
-
-        break;
       }
-
-      case Token.HOOK: {
-        Preconditions.checkState(childCount == 3);
-        int p = NodeUtil.precedence(type);
-        Context rhsContext = getContextForNoInOperator(context);
-        addExpr(first, p + 1, context);
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.HOOK))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 3);
+            int TransVarP1 = NodeUtil.precedence(TransVarNodeType);
+            Context TransVarContext = Context.OTHER;
+            addExpr(TransVarNode1, TransVarP1 + 1, TransVarCtx);
         cc.addOp("?", true);
-        addExpr(first.getNext(), 1, rhsContext);
+            addExpr(TransVarNode1.getNext(), 1, TransVarContext);
         cc.addOp(":", true);
-        addExpr(last, 1, rhsContext);
-        break;
+            addExpr(TransVarLastNode, 1, TransVarContext);
       }
-
-      case Token.REGEXP:
-        if (!first.isString() ||
-            !last.isString()) {
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.REGEXP))))) {
+            TransBreakFlag0 = false;
+            if (!(!(!TransVarNode1.isString() || !TransVarLastNode.isString()))) {
           throw new Error("Expected children to be strings");
         }
-
-        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
-
-        // I only use one .add because whitespace matters
-        if (childCount == 2) {
-          add(regexp + last.getString());
+            String TransVarFirstRegexp = regexpEscape(TransVarNode1.getString(), outputCharsetEncoder);
+            if (!(!(TransVarChildCount2 == 2))) {
+                add(TransVarFirstRegexp + TransVarLastNode.getString());
         } else {
-          Preconditions.checkState(childCount == 1);
-          add(regexp);
+                Preconditions.checkState(TransVarChildCount2 == 1);
+                add(TransVarFirstRegexp);
         }
-        break;
-
-      case Token.FUNCTION:
-        if (n.getClass() != Node.class) {
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FUNCTION))))) {
+            TransBreakFlag0 = false;
+            if (!(!(TransVarNode.getClass() != Node.class))) {
           throw new Error("Unexpected Node subclass.");
         }
-        Preconditions.checkState(childCount == 3);
-        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
-        if (funcNeedsParens) {
+            Preconditions.checkState(TransVarChildCount2 == 3);
+            boolean TransVarNeedsParens = (TransVarCtx == Context.START_OF_EXPR);
+            if (!(!(TransVarNeedsParens))) {
           add("(");
         }
-
         add("function");
-        add(first);
-
-        add(first.getNext());
-        add(last, Context.PRESERVE_BLOCK);
-        cc.endFunction(context == Context.STATEMENT);
-
-        if (funcNeedsParens) {
+            add(TransVarNode1);
+            add(TransVarNode1.getNext());
+            add(TransVarLastNode, Context.PRESERVE_BLOCK);
+            cc.endFunction(TransVarCtx == Context.STATEMENT);
+            if (!(!(TransVarNeedsParens))) {
           add(")");
         }
-        break;
-
-      case Token.GETTER_DEF:
-      case Token.SETTER_DEF:
-        Preconditions.checkState(n.getParent().isObjectLit());
-        Preconditions.checkState(childCount == 1);
-        Preconditions.checkState(first.isFunction());
-
-        // Get methods are unnamed
-        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
-        if (type == Token.GETTER_DEF) {
-          // Get methods have no parameters.
-          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETTER_DEF))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SETTER_DEF))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarNode.getParent().isObjectLit());
+            Preconditions.checkState(TransVarChildCount2 == 1);
+            Preconditions.checkState(TransVarNode1.isFunction());
+            Preconditions.checkState(TransVarNode1.getFirstChild().getString().isEmpty());
+            if (!(!(TransVarNodeType == Token.GETTER_DEF))) {
+                Preconditions.checkState(!TransVarNode1.getChildAtIndex(1).hasChildren());
           add("get ");
         } else {
-          // Set methods have one parameter.
-          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
+                Preconditions.checkState(TransVarNode1.getChildAtIndex(1).hasOneChild());
           add("set ");
         }
-
-        // The name is on the GET or SET node.
-        String name = n.getString();
-        Node fn = first;
-        Node parameters = fn.getChildAtIndex(1);
-        Node body = fn.getLastChild();
-
-        // Add the property name.
-        if (!n.isQuotedString() &&
-            TokenStream.isJSIdentifier(name) &&
-            // do not encode literally any non-literal characters that were
-            // Unicode escaped.
-            NodeUtil.isLatin(name)) {
-          add(name);
+            String TransVarName1 = TransVarNode.getString();
+            Node TransVarFnNode = TransVarNode1;
+            Node TransVarParameterNode = TransVarFnNode.getChildAtIndex(1);
+            Node TransVarBodyNode = TransVarFnNode.getLastChild();
+            if (!(!(!TransVarNode.isQuotedString() && TokenStream.isJSIdentifier(TransVarName1)
+                    && NodeUtil.isLatin(TransVarName1)))) {
+                add(TransVarName1);
         } else {
-          // Determine if the string is a simple number.
-          double d = getSimpleNumber(name);
-          if (!Double.isNaN(d)) {
-            cc.addNumber(d);
+                double TransVarDd = getSimpleNumber(TransVarName1);
+                if (!(!(!Double.isNaN(TransVarDd)))) {
+                    cc.addNumber(TransVarDd);
           } else {
-            addJsString(n);
+                    addJsString(TransVarNode);
           }
         }
-
-        add(parameters);
-        add(body, Context.PRESERVE_BLOCK);
-        break;
-
-      case Token.SCRIPT:
-      case Token.BLOCK: {
-        if (n.getClass() != Node.class) {
+            add(TransVarParameterNode);
+            add(TransVarBodyNode, Context.PRESERVE_BLOCK);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SCRIPT))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BLOCK))))) {
+            TransBreakFlag0 = false;
+            if (!(!(TransVarNode.getClass() != Node.class))) {
           throw new Error("Unexpected Node subclass.");
         }
-        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
-        if (preserveBlock) {
+            boolean TransVarPreserve = TransVarCtx == Context.PRESERVE_BLOCK;
+            if (!(!(TransVarPreserve))) {
           cc.beginBlock();
         }
-
-        boolean preferLineBreaks =
-            type == Token.SCRIPT ||
-            (type == Token.BLOCK &&
-                !preserveBlock &&
-                n.getParent() != null &&
-                n.getParent().isScript());
-        for (Node c = first; c != null; c = c.getNext()) {
-          add(c, Context.STATEMENT);
-
-          // VAR doesn't include ';' since it gets used in expressions
-          if (c.isVar()) {
+            boolean TransVarPreferLineBreak = TransVarNodeType == Token.SCRIPT || (TransVarNodeType == Token.BLOCK
+                    && !TransVarPreserve && TransVarNode.getParent() != null && TransVarNode.getParent().isScript());
+            Node TransVarChild = TransVarNode1;
+            while (!(!(TransVarChild != null))) {
+                add(TransVarChild, Context.STATEMENT);
+                if (!(!(TransVarChild.isVar()))) {
             cc.endStatement();
           }
-
-          if (c.isFunction()) {
+                if (!(!(TransVarChild.isFunction()))) {
             cc.maybeLineBreak();
           }
-
-          // Prefer to break lines in between top-level statements
-          // because top-level statements are more homogeneous.
-          if (preferLineBreaks) {
+                if (!(!(TransVarPreferLineBreak))) {
                     cc.notePreferredLineBreak();
                 }
+                TransVarChild = TransVarChild.getNext();
         }
-        if (preserveBlock) {
-          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
+            if (!(!(TransVarPreserve))) {
+                cc.endBlock(cc.breakAfterBlockFor(TransVarNode, TransVarCtx == Context.STATEMENT));
         }
-        break;
       }
-
-      case Token.FOR:
-        if (childCount == 4) {
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FOR))))) {
+            TransBreakFlag0 = false;
+            if (!(!(TransVarChildCount2 == 4))) {
           add("for(");
-          if (first.isVar()) {
-            add(first, Context.IN_FOR_INIT_CLAUSE);
+                if (!(!(TransVarNode1.isVar()))) {
+                    add(TransVarNode1, Context.IN_FOR_INIT_CLAUSE);
           } else {
-            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
+                    addExpr(TransVarNode1, 0, Context.IN_FOR_INIT_CLAUSE);
           }
           add(";");
-          add(first.getNext());
+                add(TransVarNode1.getNext());
           add(";");
-          add(first.getNext().getNext());
+                add(TransVarNode1.getNext().getNext());
           add(")");
-          addNonEmptyStatement(
-              last, getContextForNonEmptyExpression(context), false);
+                addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);
         } else {
-          Preconditions.checkState(childCount == 3);
+                Preconditions.checkState(TransVarChildCount2 == 3);
           add("for(");
-          add(first);
+                add(TransVarNode1);
           add("in");
-          add(first.getNext());
+                add(TransVarNode1.getNext());
           add(")");
-          addNonEmptyStatement(
-              last, getContextForNonEmptyExpression(context), false);
+                addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);
         }
-        break;
-
-      case Token.DO:
-        Preconditions.checkState(childCount == 2);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DO))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
         add("do");
-        addNonEmptyStatement(first, Context.OTHER, false);
+            addNonEmptyStatement(TransVarNode1, Context.OTHER, false);
         add("while(");
-        add(last);
+            add(TransVarLastNode);
         add(")");
         cc.endStatement();
-        break;
-
-      case Token.WHILE:
-        Preconditions.checkState(childCount == 2);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.WHILE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
         add("while(");
-        add(first);
+            add(TransVarNode1);
         add(")");
-        addNonEmptyStatement(
-            last, getContextForNonEmptyExpression(context), false);
-        break;
-
-      case Token.EMPTY:
-        Preconditions.checkState(childCount == 0);
-        break;
-
-      case Token.GETPROP: {
-        Preconditions.checkState(
-            childCount == 2,
-            "Bad GETPROP: expected 2 children, but got %s", childCount);
-        Preconditions.checkState(
-            last.isString(),
-            "Bad GETPROP: RHS should be STRING");
-        boolean needsParens = (first.isNumber());
-        if (needsParens) {
+            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.EMPTY))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETPROP))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2, "Bad GETPROP: expected 2 children, but got %s",
+                    TransVarChildCount2);
+            Preconditions.checkState(TransVarLastNode.isString(), "Bad GETPROP: RHS should be STRING");
+            boolean TransVarNeedsParent = (TransVarNode1.isNumber());
+            if (!(!(TransVarNeedsParent))) {
           add("(");
         }
-        addExpr(first, NodeUtil.precedence(type), context);
-        if (needsParens) {
+            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);
+            if (!(!(TransVarNeedsParent))) {
           add(")");
         }
-        if (this.languageMode == LanguageMode.ECMASCRIPT3
-            && TokenStream.isKeyword(last.getString())) {
-          // Check for ECMASCRIPT3 keywords.
+            if (!(!(this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(TransVarLastNode.getString())))) {
           add("[");
-          add(last);
+                add(TransVarLastNode);
           add("]");
         } else {
           add(".");
-          addIdentifier(last.getString());
+                addIdentifier(TransVarLastNode.getString());
         }
-        break;
       }
-
-      case Token.GETELEM:
-        Preconditions.checkState(
-            childCount == 2,
-            "Bad GETELEM: expected 2 children but got %s", childCount);
-        addExpr(first, NodeUtil.precedence(type), context);
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETELEM))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2, "Bad GETELEM: expected 2 children but got %s",
+                    TransVarChildCount2);
+            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);
         add("[");
-        add(first.getNext());
+            add(TransVarNode1.getNext());
         add("]");
-        break;
-
-      case Token.WITH:
-        Preconditions.checkState(childCount == 2);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.WITH))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
         add("with(");
-        add(first);
+            add(TransVarNode1);
         add(")");
-        addNonEmptyStatement(
-            last, getContextForNonEmptyExpression(context), false);
-        break;
-
-      case Token.INC:
-      case Token.DEC: {
-        Preconditions.checkState(childCount == 1);
-        String o = type == Token.INC ? "++" : "--";
-        int postProp = n.getIntProp(Node.INCRDECR_PROP);
-        // A non-zero post-prop value indicates a post inc/dec, default of zero
-        // is a pre-inc/dec.
-        if (postProp != 0) {
-          addExpr(first, NodeUtil.precedence(type), context);
-          cc.addOp(o, false);
+            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.INC))))) {
+            TransFallThroughFlag0 = true;
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEC))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
+            String TransVarOperator = TransVarNodeType == Token.INC ? "++" : "--";
+            int TransVarPost = TransVarNode.getIntProp(Node.INCRDECR_PROP);
+            if (!(!(TransVarPost != 0))) {
+                addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);
+                cc.addOp(TransVarOperator, false);
         } else {
-          cc.addOp(o, false);
-          add(first);
+                cc.addOp(TransVarOperator, false);
+                add(TransVarNode1);
         }
-        break;
       }
-
-      case Token.CALL:
-        // We have two special cases here:
-        // 1) If the left hand side of the call is a direct reference to eval,
-        // then it must have a DIRECT_EVAL annotation. If it does not, then
-        // that means it was originally an indirect call to eval, and that
-        // indirectness must be preserved.
-        // 2) If the left hand side of the call is a property reference,
-        // then the call must not a FREE_CALL annotation. If it does, then
-        // that means it was originally an call without an explicit this and
-        // that must be preserved.
-        if (isIndirectEval(first)
-            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CALL))))) {
+            TransBreakFlag0 = false;
+            if (!(!(isIndirectEval(TransVarNode1)
+                    || TransVarNode.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(TransVarNode1)))) {
           add("(0,");
-          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
+                addExpr(TransVarNode1, NodeUtil.precedence(Token.COMMA), Context.OTHER);
           add(")");
         } else {
-          addExpr(first, NodeUtil.precedence(type), context);
+                addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);
         }
         add("(");
-        addList(first.getNext());
+            addList(TransVarNode1.getNext());
         add(")");
-        break;
-
-      case Token.IF:
-        boolean hasElse = childCount == 3;
-        boolean ambiguousElseClause =
-            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
-        if (ambiguousElseClause) {
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.IF))))) {
+            TransBreakFlag0 = false;
+            boolean TransVarHasElseStmt = TransVarChildCount2 == 3;
+            boolean TransVarIsElseStmt = TransVarCtx == Context.BEFORE_DANGLING_ELSE && !TransVarHasElseStmt;
+            if (!(!(TransVarIsElseStmt))) {
           cc.beginBlock();
         }
-
         add("if(");
-        add(first);
+            add(TransVarNode1);
         add(")");
-
-        if (hasElse) {
-          addNonEmptyStatement(
-              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
+            if (!(!(TransVarHasElseStmt))) {
+                addNonEmptyStatement(TransVarNode1.getNext(), Context.BEFORE_DANGLING_ELSE, false);
           add("else");
-          addNonEmptyStatement(
-              last, getContextForNonEmptyExpression(context), false);
+                addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);
         } else {
-          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
-          Preconditions.checkState(childCount == 2);
+                addNonEmptyStatement(TransVarNode1.getNext(), Context.OTHER, false);
+                Preconditions.checkState(TransVarChildCount2 == 2);
         }
-
-        if (ambiguousElseClause) {
+            if (!(!(TransVarIsElseStmt))) {
           cc.endBlock();
         }
-        break;
-
-      case Token.NULL:
-        Preconditions.checkState(childCount == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NULL))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
         cc.addConstant("null");
-        break;
-
-      case Token.THIS:
-        Preconditions.checkState(childCount == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.THIS))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
         add("this");
-        break;
-
-      case Token.FALSE:
-        Preconditions.checkState(childCount == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FALSE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
         cc.addConstant("false");
-        break;
-
-      case Token.TRUE:
-        Preconditions.checkState(childCount == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TRUE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
         cc.addConstant("true");
-        break;
-
-      case Token.CONTINUE:
-        Preconditions.checkState(childCount <= 1);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CONTINUE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 <= 1);
         add("continue");
-        if (childCount == 1) {
-          if (!first.isLabelName()) {
+            if (!(!(TransVarChildCount2 == 1))) {
+                if (!(!(!TransVarNode1.isLabelName()))) {
             throw new Error("Unexpected token type. Should be LABEL_NAME.");
           }
           add(" ");
-          add(first);
+                add(TransVarNode1);
         }
         cc.endStatement();
-        break;
-
-      case Token.DEBUGGER:
-        Preconditions.checkState(childCount == 0);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEBUGGER))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0);
         add("debugger");
         cc.endStatement();
-        break;
-
-      case Token.BREAK:
-        Preconditions.checkState(childCount <= 1);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BREAK))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 <= 1);
         add("break");
-        if (childCount == 1) {
-          if (!first.isLabelName()) {
+            if (!(!(TransVarChildCount2 == 1))) {
+                if (!(!(!TransVarNode1.isLabelName()))) {
             throw new Error("Unexpected token type. Should be LABEL_NAME.");
           }
           add(" ");
-          add(first);
+                add(TransVarNode1);
         }
         cc.endStatement();
-        break;
-
-      case Token.EXPR_RESULT:
-        Preconditions.checkState(childCount == 1);
-        add(first, Context.START_OF_EXPR);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.EXPR_RESULT))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
+            add(TransVarNode1, Context.START_OF_EXPR);
         cc.endStatement();
-        break;
-
-      case Token.NEW:
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NEW))))) {
+            TransBreakFlag0 = false;
         add("new ");
-        int precedence = NodeUtil.precedence(type);
-
-        // If the first child contains a CALL, then claim higher precedence
-        // to force parentheses. Otherwise, when parsed, NEW will bind to the
-        // first viable parentheses (don't traverse into functions).
-        if (NodeUtil.containsType(
-            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
-          precedence = NodeUtil.precedence(first.getType()) + 1;
+            int TransVarPre = NodeUtil.precedence(TransVarNodeType);
+            if (!(!(NodeUtil.containsType(TransVarNode1, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)))) {
+                TransVarPre = NodeUtil.precedence(TransVarNode1.getType()) + 1;
         }
-        addExpr(first, precedence, Context.OTHER);
-
-        // '()' is optional when no arguments are present
-        Node next = first.getNext();
-        if (next != null) {
+            addExpr(TransVarNode1, TransVarPre, Context.OTHER);
+            Node TransVarNextNode = TransVarNode1.getNext();
+            if (!(!(TransVarNextNode != null))) {
           add("(");
-          addList(next);
+                addList(TransVarNextNode);
           add(")");
         }
-        break;
-
-      case Token.STRING_KEY:
-        Preconditions.checkState(
-            childCount == 1, "Object lit key must have 1 child");
-        addJsString(n);
-        break;
-
-      case Token.STRING:
-        Preconditions.checkState(
-            childCount == 0, "A string may not have children");
-        addJsString(n);
-        break;
-
-      case Token.DELPROP:
-        Preconditions.checkState(childCount == 1);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.STRING_KEY))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1, "Object lit key must have 1 child");
+            addJsString(TransVarNode);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.STRING))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 0, "A string may not have children");
+            addJsString(TransVarNode);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DELPROP))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
         add("delete ");
-        add(first);
-        break;
-
-      case Token.OBJECTLIT: {
-        boolean needsParens = (context == Context.START_OF_EXPR);
-        if (needsParens) {
+            add(TransVarNode1);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.OBJECTLIT))))) {
+            TransBreakFlag0 = false;
+            boolean TransVarNeedParen = (TransVarCtx == Context.START_OF_EXPR);
+            if (!(!(TransVarNeedParen))) {
           add("(");
         }
         add("{");
-        for (Node c = first; c != null; c = c.getNext()) {
-          if (c != first) {
+            Node TransVarCurrent = TransVarNode1;
+            while (!(!(TransVarCurrent != null))) {
+                if (!(!(TransVarCurrent != TransVarNode1))) {
             cc.listSeparator();
           }
-
-          if (c.isGetterDef() || c.isSetterDef()) {
-            add(c);
+                if (!(!(TransVarCurrent.isGetterDef() || TransVarCurrent.isSetterDef()))) {
+                    add(TransVarCurrent);
           } else {
-            Preconditions.checkState(c.isStringKey());
-            String key = c.getString();
-            // Object literal property names don't have to be quoted if they
-            // are not JavaScript keywords
-            if (!c.isQuotedString()
-                && !(languageMode == LanguageMode.ECMASCRIPT3
-                    && TokenStream.isKeyword(key))
-                && TokenStream.isJSIdentifier(key)
-                // do not encode literally any non-literal characters that
-                // were Unicode escaped.
-                && NodeUtil.isLatin(key)) {
-              add(key);
+                    Preconditions.checkState(TransVarCurrent.isStringKey());
+                    String TransVarKeyString = TransVarCurrent.getString();
+                    if (!(!(!TransVarCurrent.isQuotedString()
+                            && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(TransVarKeyString))
+                            && TokenStream.isJSIdentifier(TransVarKeyString) && NodeUtil.isLatin(TransVarKeyString)))) {
+                        add(TransVarKeyString);
             } else {
-              // Determine if the string is a simple number.
-              double d = getSimpleNumber(key);
-              if (!Double.isNaN(d)) {
-                cc.addNumber(d);
+                        double TransVarD2 = getSimpleNumber(TransVarKeyString);
+                        if (!(!(!Double.isNaN(TransVarD2)))) {
+                            cc.addNumber(TransVarD2);
               } else {
-                addExpr(c, 1, Context.OTHER);
+                            addExpr(TransVarCurrent, 1, Context.OTHER);
               }
             }
             add(":");
-            addExpr(c.getFirstChild(), 1, Context.OTHER);
+                    addExpr(TransVarCurrent.getFirstChild(), 1, Context.OTHER);
                 }
+                TransVarCurrent = TransVarCurrent.getNext();
         }
         add("}");
-        if (needsParens) {
+            if (!(!(TransVarNeedParen))) {
           add(")");
         }
-        break;
       }
-
-      case Token.SWITCH:
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SWITCH))))) {
+            TransBreakFlag0 = false;
         add("switch(");
-        add(first);
+            add(TransVarNode1);
         add(")");
         cc.beginBlock();
-        addAllSiblings(first.getNext());
-        cc.endBlock(context == Context.STATEMENT);
-        break;
-
-      case Token.CASE:
-        Preconditions.checkState(childCount == 2);
+            addAllSiblings(TransVarNode1.getNext());
+            cc.endBlock(TransVarCtx == Context.STATEMENT);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CASE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
         add("case ");
-        add(first);
-        addCaseBody(last);
-        break;
-
-      case Token.DEFAULT_CASE:
-        Preconditions.checkState(childCount == 1);
+            add(TransVarNode1);
+            addCaseBody(TransVarLastNode);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEFAULT_CASE))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 1);
         add("default");
-        addCaseBody(first);
-        break;
-
-      case Token.LABEL:
-        Preconditions.checkState(childCount == 2);
-        if (!first.isLabelName()) {
+            addCaseBody(TransVarNode1);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.LABEL))))) {
+            TransBreakFlag0 = false;
+            Preconditions.checkState(TransVarChildCount2 == 2);
+            if (!(!(!TransVarNode1.isLabelName()))) {
           throw new Error("Unexpected token type. Should be LABEL_NAME.");
         }
-        add(first);
+            add(TransVarNode1);
         add(":");
-        addNonEmptyStatement(
-            last, getContextForNonEmptyExpression(context), true);
-        break;
-
-      case Token.CAST:
+            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), true);
+        }
+        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CAST))))) {
+            TransBreakFlag0 = false;
         add("(");
-        add(first);
+            add(TransVarNode1);
         add(")");
-        break;
-
-      default:
-        throw new Error("Unknown type " + type + "\n" + n.toStringTree());
         }
+        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {
+            throw new Error("Unknown type " + TransVarNodeType + "\n" + TransVarNode.toStringTree());
+        }
+    }
 
-    cc.endSourceMapping(n);
+    cc.endSourceMapping(TransVarNode);
   }
 
   /**
